<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta http-equiv="expires" content="0">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aircraft Panel</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js"></script>

<link type="text/css" href="common.css" rel="stylesheet" />

<!-- Source: https://medium.com/@jamesweee/using-vue-js-single-file-component-without-module-bundlers-aea58d892ad9 -->
<!-- Alternative idea: https://dev.to/arswaw/create-a-lightweight-componentized-spa-without-node-569j -->
<!-- React (but lacks scoped CSS): https://stackoverflow.com/questions/36511100/how-do-i-use-react-js-without-a-bundler -->

<script type="module">
import * as Vue from 'https://unpkg.com/vue@3/dist/vue.runtime.esm-browser.prod.js';
import { loadModule } from 'https://cdn.jsdelivr.net/npm/vue3-sfc-loader@0.8.4/dist/vue3-sfc-loader.esm.js';
import Common from './Common.js';
import { Config } from './Config.js';
import Fsuipc from './Fsuipc.js';
import FsuipcConnection from './FsuipcConnection.js';
import FsuipcHtml from './FsuipcHtml.js';

var offsetMap = Fsuipc.map();
var presetCommandsMap = Fsuipc.presetCommands();
var debug = true;
var connection;
var simControls = null;

var audioObj = document.createElement('audio');
audioObj.src = 'media/one-click.wav';
audioObj.volume = 0.10;
audioObj.autoPlay = false;
audioObj.preLoad = true;

var urlParams = new URLSearchParams(window.location.search);
if (!urlParams.has('config')) {
	location.href = 'start.htm';
} else {
	var aircraftPanelId = urlParams.get('config');

	const dataStore = {  //idea: https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch (alternative ideas: https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/ --- https://stackoverflow.com/questions/64040286/access-this-root-in-vue-js-3-setup)
		debug: false,

		state: Vue.reactive({}),

		setStoreValue(method, functionRef, internalValue, valueHtml) {
			if (this.debug) {
				console.log('setStoreValue triggered with', method, functionRef, ':', valueHtml);
			}

			if (typeof this.state[method] === 'undefined') {
				this.state[method] = {
					[functionRef]: {internalValue, valueHtml}  // source: https://stackoverflow.com/questions/1184123/is-it-possible-to-add-dynamically-named-properties-to-javascript-object
				}
			} else {
				this.state[method][functionRef] = {internalValue, valueHtml};
			}
		},
	}

	// Other ideas for event handling:
	//   https://v3.vuejs.org/guide/component-basics.html#emitting-a-value-with-an-event
	//   https://v3.vuejs.org/guide/events.html#method-event-handlers
	// Accessing child component data values and methods
	//   https://forum.vuejs.org/t/vue3-accessing-child-component-data-values-and-methods/111329/4
	// Declaring props dynamically
	//   https://vuetiful.wordpress.com/2017/03/12/passing-dynamically-declared-props-in-vue-js/

	/**
	 * @param {object} options : Available options:
	 *   - `sound` : set false to not play any clicking sound
	 */
	const eventHandlers = {
		singleClick: (functionMethod, functionRef, currInternalValue, options) => {
			if (!options) options = {};

			if (options.defectWrite) return false;

			// Play sound
			if (options.sound !== false) {
				audioObj.play();
			}

			// Handle click
			var offsetsData;

			if (functionMethod === 'offset') {
				// Direct writing to offsets

				var newValue;
				var offsetName = functionRef;
				if (typeof offsetMap[offsetName] === 'undefined') {
					Common.showError('Offset name '+ offsetName +' was not found in the map.', {timeout: 6000});
					return;
				} else if (offsetMap[offsetName].type === 'bits') {
					// a value that is a given bit in an offset

					// find the new value
					newValue = (currInternalValue == true ? false : true);

					offsetsData = [
						{
							name: offsetMap[offsetName].address,
							value: [
								{ bit: offsetMap[offsetName].bit, value: newValue },
							],
						},
					];
				} else {
					// regular offset
					var toggleValues = offsetMap[offsetName].toggleValues;
					if (toggleValues) {
						// find the new value
						var currIndx = toggleValues.indexOf(currInternalValue);
						if (currIndx < toggleValues.length - 1 && currIndx !== -1) {
							newValue = toggleValues[currIndx + 1];
						} else {
							newValue = toggleValues[0];
						}

						offsetsData = [ {name: offsetName, value: newValue } ];
					} else {
						console.error('Dont know how to toggle values for offset name '+ offsetName + '.'); return;
					}
				}

				connection.sendMessage({
					command: 'offsets.write',
					name: 'aircraftOffsets',
					changesOnly: true,
					offsets: offsetsData
				});

			} else if (functionMethod === 'simControl') {
				var controlNumber = functionRef;
				var controlParameter = 0;
				if (!$.isNumeric(controlNumber)) {
				}

				offsetsData = [ {name: 'simControlParam', value: controlParameter, name: 'simControlNumber', value: controlNumber} ];

				connection.sendMessage({
					command: 'offsets.write',
					name: 'simControlOffsets',
					changesOnly: true,
					offsets: offsetsData
				});

			} else if (functionMethod === 'presetCommand') {
				var commandName = functionRef;
				if (presetCommandsMap[commandName]) {
					if (presetCommandsMap[commandName].method === 'simControl') {
						offsetsData = [
							{name: 'simControlParam', value: (typeof presetCommandsMap[commandName].parameter !== 'undefined' ? presetCommandsMap[commandName].parameter : 0)},
							{name: 'simControlNumber', value: Fsuipc.msfs20ControlNameToNumber(presetCommandsMap[commandName].control) },
						];
					} else {
						return;
					}
				} else {
					console.error('No preset command by the name of '+ offsetName + ' was found.'); return;
				}

				connection.sendMessage({
					command: 'offsets.write',
					name: 'simControlOffsets',
					offsets: offsetsData,
				});
			} else if (functionMethod === 'lVar') {
				var theVar = functionRef;
				connection.sendMessage({
					command: 'vars.write',
					vars: [
						{name: 'L:'+ theVar, value: $elem.attr('data-lvar-value')},
					],
				});
			} else if (functionMethod === 'hVar') {
				var theVar = functionRef;
				connection.sendMessage({
					command: 'vars.write',
					vars: [
						{name: 'H:'+ theVar},
					],
				});
			} else if (functionMethod === 'calcCode') {
				var presetCommand = functionRef;
				connection.sendMessage({
					command: 'vars.calc',
					name: 'calc',
					code: (presetCommand && Fsuipc.presetCommands()[presetCommand] ? Fsuipc.presetCommands()[presetCommand].code : $elem.attr('data-calc-code')),
				});
			}
		},

		knobUpDownClick: (functionMethod, functionRef, currInternalValue, direction, options) => {
			// Handle "up/down" knobs that sends commands to the sim

			// Play sound
			if (options.sound !== false) {
				audioObj.play();
			}

			// Handle click
			if (functionMethod === 'offset') {
				// Direct writing to offsets
				var offsetName = functionRef;
				var newValue, offsetsData;
				var offsetProps = offsetMap[offsetName];
				if (!offsetProps.upDownSelector || offsetProps.validValues === 'undefined') {
					console.error('The offset name '+ offsetName + ' is not defined as an up/down knob, or is valid values are missing.'); return;
				}
				var currIndx = offsetProps.validValues.indexOf(currInternalValue);
				if (direction === 'up') {
					if (currIndx < offsetProps.validValues.length - 1) {
						newValue = offsetProps.validValues[currIndx + 1];
					} else {
						return;
					}
				} else if (direction === 'down') {
					if (currIndx > 0) {
						newValue = offsetProps.validValues[currIndx - 1];
					} else {
						return;
					}
				}
				offsetsData = [ {name: offsetName, value: newValue } ];

				connection.sendMessage({
					command: 'offsets.write',
					name: 'aircraftOffsets',
					changesOnly: true,
					offsets: offsetsData,
				});
			}
		},

		aircraftInited: (aircraftValues) => {
			console.log('Aircraft panel initializing...');
			connection = new FsuipcConnection(Config.fsuipcUrl, aircraftPanelId, aircraftValues, function(method, functionRef, internalValue) {
				// Convert the final value to its HTML representation
				var valueHtml;
				if (typeof aircraftValues[method][functionRef] == 'string') {
					// The string is the name of a method in FsuipcHtml
					var htmlMethod = aircraftValues[method][functionRef];
					valueHtml = FsuipcHtml[htmlMethod](internalValue);
				} else if (typeof aircraftValues[method][functionRef] == 'function') {
					valueHtml = aircraftValues[method][functionRef](internalValue);
				}

				dataStore.setStoreValue('offset', functionRef, internalValue, valueHtml);

			}, {debug: debug});
		},
	}

	const options = {
		moduleCache: { vue: Vue },
		async getFile(url) {
			const res = await fetch(url);
			if ( !res.ok ) {
				throw Object.assign(new Error(res.statusText + ' ' + url), { res });
			}
			return {
				getContentData: (asBinary) => asBinary ? res.arrayBuffer() : res.text(),
			}
		},
		addStyle: () => {},
	}
	var app = Vue.createApp(Vue.defineAsyncComponent(() => loadModule('aircraft-panels/'+ aircraftPanelId +'.vue', options)), {dataStore, eventHandlers}).mount('#aircraft-specific-component');
}

console.log('AIRCRAFT PANEL: '+ aircraftPanelId);
</script>
</head>
<body>

<!-- 
	<a href="#" onclick="btnGetAboutInfo(); return false;" class="btn btn-secondary btn-sm disabled only-on-connected" disabled>Read info</a>
-->
	<div id="fsuipcInfo"></div>
	<div id="fsuipcReadOffsets"></div>
	<div id="errorMessage" style="color: red; font-weight: bold; position: absolute; top: 5px; left: 5px; padding: 5px; background-color: #30383d;"></div>

	<div id="aircraft-specific-component"></div>

</body>
</html>
