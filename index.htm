<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta http-equiv="expires" content="0">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aircraft Panel</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js"></script>

<link type="text/css" href="common.css" rel="stylesheet" />

<!-- Source: https://medium.com/@jamesweee/using-vue-js-single-file-component-without-module-bundlers-aea58d892ad9 -->
<!-- Alternative idea: https://dev.to/arswaw/create-a-lightweight-componentized-spa-without-node-569j -->
<!-- React (but lacks scoped CSS): https://stackoverflow.com/questions/36511100/how-do-i-use-react-js-without-a-bundler -->

<script type="module">
import * as Vue from 'https://unpkg.com/vue@3/dist/vue.runtime.esm-browser.js';
import { loadModule } from 'https://cdn.jsdelivr.net/npm/vue3-sfc-loader@0.8.4/dist/vue3-sfc-loader.esm.js';
import Common from './Common.js';
import { Config } from './Config.js';
import Fsuipc from './Fsuipc.js';
import FsuipcConnection from './FsuipcConnection.js';
import FsuipcHtml from './FsuipcHtml.js';

var offsetMap = Fsuipc.map();
var lVarOptions = Fsuipc.lVarOptions();
var presetCommands = Fsuipc.presetCommands();
var debug = true;
var connection;
var simControls = null;

var audioObj = document.createElement('audio');
audioObj.src = 'media/one-click.wav';
audioObj.volume = 0.10;
audioObj.autoPlay = false;
audioObj.preLoad = true;

var urlParams = new URLSearchParams(window.location.search);
if (!urlParams.has('config')) {
	location.href = 'start.htm';
} else {
	var aircraftPanelId = urlParams.get('config');

	const dataStore = {  //idea: https://v3.vuejs.org/guide/state-management.html#simple-state-management-from-scratch (alternative ideas: https://blog.logrocket.com/provide-inject-vue-js-3-composition-api/ --- https://stackoverflow.com/questions/64040286/access-this-root-in-vue-js-3-setup)
		debug: false,

		state: Vue.reactive({}),

		setStoreValue(method, action, internalValue, valueHtml) {
			if (this.debug) {
				console.log('setStoreValue triggered with', method, action, ':', valueHtml);
			}

			if (typeof this.state[method] === 'undefined') {
				this.state[method] = {
					[action]: {internalValue, valueHtml}  // source: https://stackoverflow.com/questions/1184123/is-it-possible-to-add-dynamically-named-properties-to-javascript-object
				}
			} else {
				this.state[method][action] = {internalValue, valueHtml};
			}
		},
	}

	// Other ideas for event handling:
	//   https://v3.vuejs.org/guide/component-basics.html#emitting-a-value-with-an-event
	//   https://v3.vuejs.org/guide/events.html#method-event-handlers
	// Accessing child component data values and methods
	//   https://forum.vuejs.org/t/vue3-accessing-child-component-data-values-and-methods/111329/4
	// Declaring props dynamically
	//   https://vuetiful.wordpress.com/2017/03/12/passing-dynamically-declared-props-in-vue-js/

	/**
	 * @param {object} options : Available options (either currInternalValue or newInternalValue must be set):
	 *   - `currInternalValue` : set this for toggling states, otherwise set it as undefined
	 *   - `newInternalValue` : set this to set a specific value, otherwise set it as undefined
	 *   - `sound` : set false to not play any clicking sound
	 */
	const eventHandlers = {
		singleClick: (method, action, currInternalValue, newInternalValue, options) => {
			if (!options) options = {};

			if (options.defectWrite) return false;

			// Play sound
			if (options.sound !== false) {
				audioObj.play();
			}

			// Handle click
			var newValue, offsetsData;

			if (method === 'offset') {
				// Direct writing to offsets

				var offsetName = action;
				if (typeof offsetMap[offsetName] === 'undefined') {
					Common.showError('Offset name '+ offsetName +' was not found in the map.', {timeout: 6000});
					return;
				} else if (offsetMap[offsetName].type === 'bits') {
					// a value that is a given bit in an offset

					// find the new value
					newValue = (currInternalValue == true ? false : true);

					offsetsData = [
						{
							name: offsetMap[offsetName].address,
							value: [
								{ bit: offsetMap[offsetName].bit, value: newValue },
							],
						},
					];
				} else {
					// regular offset
					if (newInternalValue != null) {
						newValue = newInternalValue;
					} else if (typeof offsetMap[offsetName].toggleValues !== 'undefined') {
						newValue = Common.getNextToggleValue(offsetMap[offsetName].toggleValues, currInternalValue);
					} else {
						console.error('Dont know how to determine new value for offset name '+ offsetName + '.');
					}
					if (newValue != null) {
						offsetsData = [ {name: offsetName, value: newValue } ];
					}
				}

				if (offsetsData) {
					connection.sendMessage({
						command: 'offsets.write',
						name: 'aircraftOffsets',
						changesOnly: true,
						offsets: offsetsData,
					});
				}

			} else if (method === 'lVar') {
				var theLVar = action;
				if (newInternalValue != null) {
					newValue = newInternalValue;
				} else if (typeof lVarOptions[theLVar].toggleValues !== 'undefined') {
					newValue = Common.getNextToggleValue(lVarOptions[theLVar].toggleValues, currInternalValue);
				} else {
					console.error('Dont know how to determine new value for lVar name '+ theLVar + '.');
				}
				if (newValue != null) {
					offsetsData = [ {name: theLVar, value: newValue } ];
				}

				if (offsetsData) {
					connection.sendMessage({
						command: 'vars.write',
						vars: [
							{name: theLVar, value: newValue},
						],
					});
				}

			} else if (method === 'simControl') {
				var controlNumber = action;
				console.info('Writing Lvars is not fully supported yet');
				var controlParameter = 0;  //TODO: allow passing the parameter value to be used
				// if (!$.isNumeric(controlNumber)) {
				// }

				offsetsData = [ {name: 'simControlParam', value: controlParameter, name: 'simControlNumber', value: controlNumber} ];

				connection.sendMessage({
					command: 'offsets.write',
					name: 'simControlOffsets',
					changesOnly: true,
					offsets: offsetsData,
				});

			} else if (method === 'presetCommand') {
				var commandName = action;
				if (presetCommands[commandName]) {
					if (typeof presetCommands[commandName] === 'undefined') {
						Common.showError('Command "'+ offsetName +'" was not found in list of preset commands. If this was a preset from MobiFlight it might have been changed or removed in place of something else. Please update /databases/MobiFlightHubHopPresets.js with the latest version and look for another preset to use in its place. Searching on https://hubhop.mobiflight.com/ might be of a help to you.', {timeout: 40000});
					} else if (presetCommands[commandName].method === 'simControl') {
						offsetsData = [
							{name: 'simControlParam', value: (typeof presetCommands[commandName].parameter !== 'undefined' ? presetCommands[commandName].parameter : 0)},
							{name: 'simControlNumber', value: Fsuipc.msfs20ControlNameToNumber(presetCommands[commandName].control) },
						];
						connection.sendMessage({
							command: 'offsets.write',
							name: 'simControlOffsets',
							offsets: offsetsData,
						});
					} else if (presetCommands[commandName].method === 'calcCode') {
						connection.sendMessage({
							command: 'vars.calc',
							name: 'calc',
							code: presetCommands[commandName].code,
						});
					} else {
						console.error('Dont know how to handle method '+ presetCommands[commandName].method + ' in event handler.');
					}
				} else {
					console.error('No preset command by the name of '+ offsetName + ' was found.');
				}

			} else if (method === 'hVar') {
				var theHVar = action;
				connection.sendMessage({
					command: 'vars.write',
					vars: [
						{name: 'H:'+ theHVar},
					],
				});

			} else if (method === 'calcCode') {
				var calculatorCode = action;
				connection.sendMessage({
					command: 'vars.calc',
					name: 'calc',
					code: calculatorCode,
				});
			}
		},

		/**
		 * Handle up/down knobs that sends commands to the sim
		 */
		knobUpDownClick: (method, action, currInternalValue, direction, options) => {
			if (!options) options = {};

			// Play sound
			if (options.sound !== false) {
				audioObj.play();
			}

			// Handle click
			if (method === 'offset') {
				// Direct writing to offsets
				var offsetName = action;
				var newValue, offsetsData;
				var offsetProps = offsetMap[offsetName];
				if (!offsetProps.upDownSelector || offsetProps.validValues === 'undefined') {
					console.error('The offset name '+ offsetName + ' is not defined as an up/down knob, or is valid values are missing.'); return;
				}
				var currIndx = offsetProps.validValues.indexOf(currInternalValue);
				if (direction === 'up') {
					if (currIndx < offsetProps.validValues.length - 1) {
						newValue = offsetProps.validValues[currIndx + 1];
					} else {
						return;
					}
				} else if (direction === 'down') {
					if (currIndx > 0) {
						newValue = offsetProps.validValues[currIndx - 1];
					} else {
						return;
					}
				}
				offsetsData = [ {name: offsetName, value: newValue } ];

				connection.sendMessage({
					command: 'offsets.write',
					name: 'aircraftOffsets',
					changesOnly: true,
					offsets: offsetsData,
				});
			}
		},

		aircraftInited: (aircraftValues) => {
			console.log('Aircraft panel initializing...');
			connection = new FsuipcConnection(Config.fsuipcUrl, aircraftPanelId, aircraftValues, function(method, action, internalValue) {
				// Convert the final value to its HTML representation
				var valueHtml;
				if (typeof aircraftValues[method][action] == 'string') {
					// The string is the name of a method in FsuipcHtml
					var htmlMethod = aircraftValues[method][action];
					valueHtml = FsuipcHtml[htmlMethod](internalValue);
				} else if (typeof aircraftValues[method][action] == 'function') {
					valueHtml = aircraftValues[method][action](internalValue);
				}

				dataStore.setStoreValue(method, action, internalValue, valueHtml);

			}, {debug: debug});
		},
	}

	const options = {
		moduleCache: { vue: Vue },
		async getFile(url) {
			const res = await fetch(url);
			if ( !res.ok ) {
				throw Object.assign(new Error(res.statusText + ' ' + url), { res });
			}
			return {
				type: (url.endsWith('.js') ? '.mjs' : '.vue'),
				getContentData: (asBinary) => asBinary ? res.arrayBuffer() : res.text(),
			}
		},
		addStyle: (textContent) => {
			const style = Object.assign(document.createElement('style'), { textContent });
			const ref = document.head.getElementsByTagName('style')[0] || null;
			document.head.insertBefore(style, ref);
		},
		log(type, ...args) {
			console[type](...args);
		},
	}
	var app = Vue.createApp(Vue.defineAsyncComponent(() => loadModule('aircraft-panels/'+ aircraftPanelId +'.vue', options)), {dataStore, eventHandlers}).mount('#aircraft-specific-component');
}

console.log('AIRCRAFT PANEL: '+ aircraftPanelId);
</script>
</head>
<body>

<!--
	<a href="#" onclick="btnGetAboutInfo(); return false;" class="btn btn-secondary btn-sm disabled only-on-connected" disabled>Read info</a>
-->
	<div id="fsuipcInfo"></div>
	<div id="fsuipcReadOffsets"></div>
	<div id="errorMessage" style="color: red; font-weight: bold; position: absolute; top: 5px; left: 5px; padding: 5px; background-color: #30383d;"></div>

	<div id="aircraft-specific-component"></div>

</body>
</html>
